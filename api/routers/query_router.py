from fastapi import APIRouter, HTTPException, Depends, status
from typing import Optional
from api.schemas import QueryRequest, QueryResponse
from api.utils import create_access_token
from api.database import get_db
import openai
from sqlalchemy.orm import Session
import os
import requests
from fastapi.responses import JSONResponse
from pydantic import BaseModel

# Import Statements
# 1. Core Modules
from datetime import datetime
from typing import Union

# 2. Third-Party Libraries
import openai  # OpenAI API client
from fastapi.responses import JSONResponse  # For custom response handling

# 3. Internal Modules
from api.schemas import QueryRequest, QueryResponse  # Data models for requests and responses
from api.database import get_db  # Dependency function for database sessions
from api.utils import create_access_token # Utility function for JWT token generation
from api.utils import verify_password # Utility function for password verification
from api.database import models  # Import database models
from api.database import schemas  # Import schemas

# Environment Variables
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY") # OpenAI API key 
JWT_SECRET_KEY = os.getenv("JWT_SECRET_KEY") # JWT Secret Key
DATABASE_URL = os.getenv("DATABASE_URL") # Database URL

# Initialize OpenAI Client
openai.api_key = OPENAI_API_KEY

# Router Definition
query_router = APIRouter()

# API Endpoint for Generating Responses
@query_router.post("/query")
async def generate_response(query_request: QueryRequest, db: Session = Depends(get_db)):
    """
    Handles user queries and generates responses using the OpenAI API.

    Args:
        query_request (QueryRequest): The user's query request, including model, query, temperature, and max_tokens.
        db (Session, optional): The database session for storing query data (optional).

    Returns:
        QueryResponse: The response generated by the OpenAI model, including query information.
    """

    try:
        # Validate User Input
        if not query_request.model or not query_request.query:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST, detail="Model and query are required."
            )

        # Translate Query to OpenAI API Format
        model_name = query_request.model
        query = query_request.query
        temperature = query_request.temperature  # Control creativity
        max_tokens = query_request.max_tokens  # Limit response length

        # Interact with the OpenAI API
        response = openai.Completion.create(
            model=model_name,
            prompt=query,
            temperature=temperature,
            max_tokens=max_tokens,
        )

        # Process and Format the Response
        ai_response = response["choices"][0]["text"].strip()

        # Store Query Data in Database (optional)
        if db:
            query_data = models.Query(
                model=model_name,
                query=query,
                response=ai_response,
                # Add other relevant fields
            )
            db.add(query_data)
            db.commit()
            db.refresh(query_data)

        # Return the Response
        return QueryResponse(
            id=query_data.id if db else None,  # Include query ID if stored
            model=model_name,
            query=query,
            response=ai_response,
            # Add other fields as needed
        )

    except openai.error.InvalidRequestError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST, detail=f"Invalid OpenAI API request: {e}"
        )
    except openai.error.APIError as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"OpenAI API error: {e}"
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Internal server error: {e}"
        )

# API Endpoint for Authenticating Users and Generating JWT Tokens
@query_router.post("/token")
async def login_for_access_token(form_data: schemas.User):
    """
    Authenticates a user based on username and password, and generates a JWT access token.

    Args:
        form_data (schemas.User): The user's credentials, including username and password.

    Returns:
        JSONResponse: A JSON response containing the JWT access token.
    """

    user = get_user(form_data.username, db)
    if user is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    if not verify_password(form_data.password, user.password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )

    access_token = create_access_token(
        data={"sub": user.username}
    )
    return JSONResponse(
        content={"access_token": access_token, "token_type": "bearer"}
    )


def get_user(username: str, db: Session):
    """
    Retrieves a user from the database based on the username.

    Args:
        username (str): The username to search for.
        db (Session): The database session.

    Returns:
        models.User: The user object if found, otherwise None.
    """

    return db.query(models.User).filter(models.User.username == username).first()